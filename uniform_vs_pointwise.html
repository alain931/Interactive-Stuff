<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Uniform vs Pointwise Convergence Lab</title>

  <!-- Plotly -->
  <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist-min@2.35.2/plotly.min.js"></script>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});">
  </script>

  <style>
    :root{
      --bg: #0f1220;
      --panel: #151a2d;
      --panel-2: #0d1324;
      --text: #e7ecf7;
      --muted: #aab2c8;
      --accent: #7aa2ff;    /* cool blue */
      --accent-2: #ff7a9e;  /* hot pink */
      --ok: #8ee38e;
      --warn: #ffd166;
      --err: #ff6b6b;
      --band-eps: rgba(255, 122, 158, 0.18);
      --card-radius: 16px;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; color: var(--text);
      background: radial-gradient(1200px 600px at 20% -10%, #1e2548 0%, var(--bg) 60%); }

    h1 { font-weight: 800; letter-spacing: 0.3px; margin: 0 0 8px; }
    .sub { color: var(--muted); margin-bottom: 18px; }

    .app { display: flex; gap: 0; padding: 20px; height: calc(100vh - 40px); }
    .left-panel { width: 380px; min-width: 220px; max-width: 640px; flex-shrink: 0; }
    .right-panel { flex: 1; min-width: 320px; }
    .resizer { width: 6px; background: linear-gradient(180deg, #2a3358, #1f2745); cursor: col-resize; position: relative; margin: 0 6px; border-radius: 3px; }
    .resizer:hover { background: linear-gradient(180deg, #3a4575, #2f3855); }
    .resizer::before { content:''; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:2px; height:20px; background:var(--muted); opacity:.5; border-radius:1px; }

    @media (max-width: 1000px){ .app{ flex-direction: column; height: auto; } .resizer { display: none; } .left-panel { width: 100%; max-width: none; } }

    .panel {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid #1f2745;
      border-radius: var(--card-radius);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
    }
    .panel h2 { margin: 4px 0 12px; font-size: 18px; }

    .row { display: grid; grid-template-columns: 1fr 140px; gap: 12px; align-items: center; margin: 10px 0 14px; }
    .row label { font-size: 13px; color: var(--muted); }

    select, input[type="number"], input[type="range"] {
      width: 100%; border-radius: 12px; border: 1px solid #2a3358; background: #0c1122; color: var(--text);
      padding: 10px 12px; outline: none; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
    }
    input[type="range"] { padding: 0; height: 28px; }
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: none; box-shadow: 0 0 0 3px rgba(122,162,255,0.25); }
    input[type="range"]::-moz-range-thumb{ width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: none; box-shadow: 0 0 0 3px rgba(122,162,255,0.25); }

    .stat { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 12px; border: 1px solid #263056; background: #0a1021; margin-top: 8px; }
    .stat .val { font-weight: 700; }

    .badge { display:inline-flex; align-items:center; gap:8px; border-radius: 999px; padding: 6px 10px; font-size: 12px; border: 1px solid #2d3564; background:#0b1123; }
    .badge.ok { border-color:#265335; background:#11281a; color:var(--ok); }
    .badge.no { border-color:#5a1e29; background:#2b0f1b; color:var(--err); }
    .badge.warn { border-color:#5a4a1e; background:#2b230f; color:var(--warn); }

    .mathblock { background: #0a0f20; border: 1px solid #202848; border-radius: 14px; padding: 10px 14px; margin-top: 10px; overflow-x: auto; }
    .mathblock .katex-display { margin: 0.6rem 0; }
    .legend { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #2d3564; background: #0b1123; color: var(--text); font-size: 11px; }

    .btns { display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    .btn { appearance: none; border: 1px solid #2a3358; background: #0c1122; color: var(--text); padding: 8px 12px; border-radius: 12px; cursor: pointer; }
    .btn:hover{ border-color: #3a4575; }
    .btn.primary{ background: linear-gradient(180deg, #2a49ff, #6a89ff); border: none; box-shadow: 0 8px 24px rgba(106,137,255,0.35); }

    /* ---------- Custom Combobox (KaTeX-capable) ---------- */
    .ux-combo{ position:relative; }
    .combo-btn{ width:100%; display:flex; align-items:center; justify-content:space-between; border-radius:12px; border:1px solid #2a3358; background:#0c1122; color:var(--text); padding:10px 12px; cursor:pointer; }
    .combo-btn:focus{ outline:2px solid #6a89ff55; }
    .combo-btn .label{ display:flex; align-items:center; gap:8px; }
    .combo-btn .opt-note{ color:var(--muted); font-size:12px; }
    .combo-caret{ width:14px; height:14px; opacity:0.8; margin-left:8px; }
    .combo-list{ position:absolute; top:calc(100% + 6px); left:0; right:0; background:#0c1122; border:1px solid #2a3358; border-radius:12px; box-shadow:var(--shadow); max-height:260px; overflow:auto; padding:6px; display:none; z-index:50; }
    .combo-list.open{ display:block; }
    .combo-list li{ list-style:none; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:8px 10px; border-radius:10px; cursor:pointer; }
    .combo-list li[aria-selected="true"], .combo-list li:hover{ background:#11183a; }
    .combo-list .opt-note{ color:var(--muted); font-size:11px; white-space:nowrap; }
    .combo-list .opt-math .katex{ font-size: 1rem; }

    #plot { height: 85vh; min-height: 600px; }
    footer { padding: 8px 20px 16px; color: var(--muted); font-size: 12px; text-align: center; }
  </style>
</head>
<body>
  <div class="app">
    <section class="left-panel">
      <div class="panel">
        <h1>Uniform vs Pointwise Convergence</h1>
        <div class="sub">
          Make the $\varepsilon$–$N$ story visual. Compare $f_n$ to its pointwise limit $f$, watch $\sup_x |f_n-f|$, and test uniformity.
        </div>

        <div class="row">
          <label id="famLabel">Family $(f_n)$</label>
          <div class="ux-combo" id="famCombo" aria-labelledby="famLabel">
            <button id="famBtn" class="combo-btn" role="combobox" aria-controls="famList" aria-expanded="false" aria-haspopup="listbox">
              <div class="label"><span id="famBtnText"></span></div>
              <svg class="combo-caret" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M7 10l5 5 5-5z"/></svg>
            </button>
            <ul id="famList" class="combo-list" role="listbox" tabindex="-1" aria-activedescendant="opt-xn">
              <li role="option" data-value="xn" id="opt-xn" aria-selected="true">
                <span class="opt-math">$$f_n(x)=x^n,\ x\in[0,1]$$</span>
                <span class="opt-note">pointwise, not uniform</span>
              </li>
              <li role="option" data-value="sinn" id="opt-sinn" aria-selected="false">
                <span class="opt-math">$$f_n(x)=\\sin(nx)/n,\ x\in[0,2\\pi]$$</span>
                <span class="opt-note">uniform</span>
              </li>
              <li role="option" data-value="cauchy" id="opt-cauchy" aria-selected="false">
                <span class="opt-math">$$f_n(x)=\\dfrac{n}{1+n^2x^2},\ x\in\\mathbb R$$</span>
                <span class="opt-note">fails at x=0</span>
              </li>
            </ul>
          </div>
        </div>
        <div id="famPreview" class="legend" style="margin-top:-6px; margin-bottom:8px;"></div>

        <div class="row" id="rowN">
          <label for="nRange">Index $n$</label>
          <input id="nRange" type="range" min="1" max="300" step="1" value="20" />
          <input id="nBox" type="number" min="1" max="300" step="1" value="20" />
        </div>

        <div class="row">
          <label for="epsRange">$\varepsilon$</label>
          <input id="epsRange" type="range" min="0.0001" max="0.5" step="0.0001" value="0.05" />
          <input id="epsBox" type="number" min="0.0001" max="1" step="0.0001" value="0.05" />
        </div>

        <div id="rowWindow" class="row" style="display:none">
          <label for="win">Window $[-W,W]$ (for $\mathbb R$)</label>
          <input id="win" type="range" min="1" max="20" step="1" value="6" />
          <input id="winBox" type="number" min="1" max="20" step="1" value="6" />
        </div>

        <div id="rowExclude" class="row" style="display:none">
          <label for="delta">Exclude $|x|\lt \delta$ (theory aid)</label>
          <input id="delta" type="range" min="0" max="0.5" step="0.001" value="0.0" />
          <input id="deltaBox" type="number" min="0" max="0.5" step="0.001" value="0.0" />
        </div>

        <div class="btns">
          <button class="btn" id="toggleMode">Heatmap: off</button>
          <button class="btn" id="savePngBtn">Save PNG</button>
          <button class="btn primary" id="resetBtn">Reset</button>
        </div>

        <div class="stat"><div>Current $\sup_x |f_n-f|$</div><div class="val" id="supVal" aria-live="polite">—</div></div>
        <div class="stat"><div>Grid resolution</div><div class="val" id="gridVal" aria-live="polite">—</div></div>
        <div class="stat"><div>ε-test at current n</div><div class="val" id="epsVerdict" aria-live="polite">—</div></div>
        <div class="stat"><div>Uniform? (theory)</div><div class="val" id="badge">—</div></div>

        <div class="mathblock" id="formal">
          $$\textbf{Uniform vs Pointwise.}\\
            (f_n) \to f \text{ pointwise if }\forall x\,\forall \varepsilon>0\,\exists N\,\forall n>N:\ |f_n(x)-f(x)|<\varepsilon.\\
            (f_n) \to f \text{ uniformly if }\forall \varepsilon>0\,\exists N\,\forall n>N\,\forall x:\ |f_n(x)-f(x)|<\varepsilon. $$

          $$\text{We visualize } \varepsilon \text{-bands and compute } \sup_x |f_n-f|\text{ over the chosen domain.}$$
        </div>

        <div class="legend">
          Curves: <span class="pill">$f_n$</span> (blue) vs <span class="pill">limit $f$</span> (pink) with <span class="pill">$\varepsilon$-band</span> (shaded). Drag $\varepsilon$ to see band width change. Heatmap shows minimal $N(\varepsilon,x)$.
        </div>
      </div>
    </section>

    <div class="resizer" id="resizer"></div>

    <section class="right-panel">
      <div class="panel">
        <div id="plot"></div>
      </div>
    </section>
  </div>



<script>
(() => {
  // ---------- Utilities ----------
  const TAU = Math.PI * 2;
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const fmt = x => {
    if (!isFinite(x)) return '—';
    const ax = Math.abs(x);
    if (ax >= 1000) return x.toFixed(0);
    if (ax >= 1)    return x.toFixed(5).replace(/0+$/,'').replace(/\.$/,'');
    if (ax >= 1e-3) return x.toFixed(7).replace(/0+$/,'').replace(/\.$/,'');
    return x.toExponential(2);
  };

  // families
  const FAMS = {
    xn: {
      name: 'x^n on [0,1]',
      domain: {kind:'interval', a:0, b:1},
      f: (n,x)=>Math.pow(x,n),
      lim: x => (x > 1 - 1e-12 ? 1 : 0),
      theoreticalUniform: false
    },
    sinn: {
      name: 'sin(nx)/n on [0,2π]',
      domain: {kind:'interval', a:0, b:TAU},
      f: (n,x)=>Math.sin(n*x)/n,
      lim: x => 0,
      theoreticalUniform: true
    },
    cauchy: {
      name: 'n/(1+n^2 x^2) on ℝ',
      domain: {kind:'window', W:6},
      f: (n,x)=> n/(1 + n*n*x*x),
      lim: x => (x===0 ? NaN : 0), // undefined at 0 (no pointwise limit)
      theoreticalUniform: false
    }
  };

  // elements
  const elFamCombo = document.getElementById('famCombo');
  const elFamBtn = document.getElementById('famBtn');
  const elFamBtnText = document.getElementById('famBtnText');
  const elFamList = document.getElementById('famList');
  const elNRange = document.getElementById('nRange');
  const elNBox = document.getElementById('nBox');
  const elEpsR = document.getElementById('epsRange');
  const elEpsB = document.getElementById('epsBox');
  const elWin = document.getElementById('win');
  const elWinBox = document.getElementById('winBox');
  const elDelta = document.getElementById('delta');
  const elDeltaBox = document.getElementById('deltaBox');
  const rowWindow = document.getElementById('rowWindow');
  const rowExclude = document.getElementById('rowExclude');
  const elToggleMode = document.getElementById('toggleMode');
  const elReset = document.getElementById('resetBtn');
  const btnSave = document.getElementById('savePngBtn');
  const elSup = document.getElementById('supVal');
  const elGrid = document.getElementById('gridVal');
  const elEpsVerdict = document.getElementById('epsVerdict');
  const elBadge = document.getElementById('badge');
  const elFamPreview = document.getElementById('famPreview');

  // meta for button label
  const FAM_META = {
    xn:   { tex: 'f_n(x)=x^n',                 note: 'on [0,1] — pointwise, not uniform' },
    sinn: { tex: 'f_n(x)=\\sin(nx)/n',         note: 'on [0,2\\pi] — uniform' },
    cauchy: { tex: 'f_n(x)=\\dfrac{n}{1+n^2x^2}', note: 'on ℝ — fails at x=0' }
  };

  // state
  let writingHash = false;
  let activeIndex = 0;
  let raf = 0;
  const state = {
    fam: 'xn',
    n: 20,
    eps: 0.05,
    W: 6,
    delta: 0.0,
    heatmap: false,
  };

  // adaptive grid resolution
  function currentGridN(n, fam) {
    return (fam === 'sinn') ? Math.max(600, 80 * n) : 600; // ~80 samples/period
  }

  // analytic supremum (exact when known)
  function analyticSup() {
    if (state.fam === 'sinn') return 1 / state.n;
    if (state.fam === 'xn')   return 1;       // exact on [0,1]
    if (state.fam === 'cauchy' && state.delta > 0) return state.n / (1 + state.n*state.n*state.delta*state.delta);
    return null; // skip for cauchy when delta=0 (undefined at x=0)
  }

  // permalink
  function writeHash(){
    writingHash = true;
    const q = new URLSearchParams({fam:state.fam,n:state.n,eps:state.eps,W:state.W,delta:state.delta,heat:state.heatmap?1:0}).toString();
    if (location.hash.slice(1)!==q) location.hash = q;
    writingHash = false;
  }
  function readHash(){
    const h = new URLSearchParams(location.hash.slice(1));
    if (h.has('fam')) state.fam = h.get('fam');
    if (h.has('n')) state.n = clamp(parseInt(h.get('n'),10)||20,1,300);
    if (h.has('eps')) state.eps = Math.max(1e-6, parseFloat(h.get('eps'))||0.05);
    if (h.has('W')) state.W = clamp(parseInt(h.get('W'),10)||6,1,20);
    if (h.has('delta')) state.delta = clamp(parseFloat(h.get('delta'))||0,0,0.5);
    if (h.has('heat')) state.heatmap = h.get('heat')==='1';
  }

  // UI sync
  function syncUI(){
    elNRange.value = state.n; elNBox.value = state.n;
    elEpsR.value = state.eps; elEpsB.value = state.eps;
    elWin.value = state.W; elWinBox.value = state.W;
    elDelta.value = state.delta; elDeltaBox.value = state.delta;

    const fam = FAMS[state.fam];
    rowWindow.style.display = (state.fam==='cauchy') ? '' : 'none';
    rowExclude.style.display = (state.fam==='cauchy') ? '' : 'none';

    elToggleMode.textContent = `Heatmap: ${state.heatmap? 'on':'off'}`;

    // dim n controls in heatmap mode (since n doesn't affect heatmap)
    const rowN = document.getElementById('rowN');
    if (rowN) {
      rowN.style.opacity = state.heatmap ? 0.4 : 1;
      rowN.querySelectorAll('input').forEach(i => i.disabled = state.heatmap);
    }

    // badge (theory)
    elBadge.innerHTML = '';
    const b = document.createElement('span');
    b.className = 'badge ' + (fam.theoreticalUniform ? 'ok' : (state.fam==='cauchy' ? 'warn' : 'no'));
    b.textContent = fam.theoreticalUniform ? 'Yes (theory)' : (state.fam==='cauchy' ? 'Fails at x=0' : 'No (theory)');
    elBadge.appendChild(b);

    // update combo selection styles
    Array.from(elFamList.querySelectorAll('[role="option"]')).forEach((li,i)=>{
      const selected = (li.dataset.value===state.fam);
      li.setAttribute('aria-selected', selected? 'true':'false');
      if (selected) { activeIndex = i; elFamList.setAttribute('aria-activedescendant', li.id); }
    });

    updatePreview();
    updateFamButton();
  }

  function updatePreview(){
    if (!elFamPreview) return;
    let tex = '';
    if (state.fam==='xn') tex = '$$f_n(x)=x^n,\\ x\\in[0,1]$$';
    else if (state.fam==='sinn') tex = '$$f_n(x)=\\sin(nx)/n,\\ x\\in[0,2\\pi]$$';
    else if (state.fam==='cauchy') tex = '$$f_n(x)=\\dfrac{n}{1+n^2x^2},\\ x\\in\\mathbb R$$';
    elFamPreview.innerHTML = tex;
    if (window.renderMathInElement){
      renderMathInElement(elFamPreview,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});
    }
  }

  function updateFamButton(){
    const meta = FAM_META[state.fam];
    const math = (window.katex ? katex.renderToString(meta.tex,{throwOnError:false}) : meta.tex);
    elFamBtnText.innerHTML = `<span class="ktx">${math}</span> <span class="opt-note">${meta.note}</span>`;
  }

  // ----- Combobox controls -----
  function openList(){ elFamList.classList.add('open'); elFamBtn.setAttribute('aria-expanded','true'); elFamList.focus({preventScroll:true}); }
  function closeList(){ elFamList.classList.remove('open'); elFamBtn.setAttribute('aria-expanded','false'); }
  function isOpen(){ return elFamList.classList.contains('open'); }

  function selectFam(value){
    if (!FAMS[value]) return;
    state.fam = value;
    syncUI();
    scheduleDraw();
    closeList();
  }

  function moveActive(delta){
    const items = Array.from(elFamList.querySelectorAll('[role="option"]'));
    activeIndex = (activeIndex + delta + items.length) % items.length;
    const li = items[activeIndex];
    elFamList.setAttribute('aria-activedescendant', li.id);
    items.forEach(el=> el.classList.toggle('active', el===li));
    li.scrollIntoView({block:'nearest'});
  }

  elFamBtn.addEventListener('click', ()=>{ isOpen()? closeList() : openList(); });
  elFamBtn.addEventListener('keydown', (e)=>{
    if (e.key==='ArrowDown' || e.key==='Enter' || e.key===' '){ e.preventDefault(); openList(); }
  });
  elFamList.addEventListener('keydown', (e)=>{
    if (e.key==='Escape'){ e.preventDefault(); closeList(); elFamBtn.focus(); }
    else if (e.key==='ArrowDown'){ e.preventDefault(); moveActive(1); }
    else if (e.key==='ArrowUp'){ e.preventDefault(); moveActive(-1); }
    else if (e.key==='Home'){ e.preventDefault(); activeIndex=0; moveActive(0); }
    else if (e.key==='End'){ e.preventDefault(); const n=elFamList.querySelectorAll('[role="option"]').length-1; activeIndex=n; moveActive(0); }
    else if (e.key==='Enter'){ e.preventDefault(); const li = elFamList.querySelectorAll('[role="option"]')[activeIndex]; selectFam(li.dataset.value); }
  });
  elFamList.addEventListener('click', (e)=>{
    const li = e.target.closest('[role="option"]');
    if (!li) return;
    selectFam(li.dataset.value);
  });
  window.addEventListener('click', (e)=>{ if (!elFamCombo.contains(e.target)) closeList(); });

  // domain sampling
  function sampleDomain(){
    const fam = FAMS[state.fam];
    const N = currentGridN(state.n, state.fam);
    let xs = [];
    if (fam.domain.kind==='interval'){
      const {a,b} = fam.domain; xs = Array.from({length:N}, (_,i)=> a + (b-a)*i/(N-1));
    } else {
      // window symmetric [-W, W]
      const W = state.W; const a=-W, b=W; xs = Array.from({length:N}, (_,i)=> a + (b-a)*i/(N-1));
    }
    if (state.fam==='cauchy' && state.delta>0){
      const d = state.delta;
      xs = xs.filter(x => Math.abs(x)>=d);
    }
    return xs;
  }

  // compute sup |f_n - f|
  function supError(xs){
    const fam = FAMS[state.fam];
    const fn = fam.f.bind(null, state.n);
    const f0 = fam.lim;
    let sup = 0, bad = false;
    for (const x of xs){
      const L = f0(x);
      if (!isFinite(L) && !isNaN(L)) { bad = true; continue; }
      if (Number.isNaN(L)) { bad = true; continue; } // undefined limit at this x
      const v = Math.abs(fn(x) - L);
      if (v>sup) sup = v;
    }
    if (bad && state.fam==='cauchy' && state.delta===0) return NaN; // includes x=0 -> undefined pointwise
    return sup;
  }

  // plotting
  function drawCurves(){
    const fam = FAMS[state.fam];
    const xs = sampleDomain();
    const fn = fam.f.bind(null, state.n);
    const f0 = fam.lim;

    const ys = xs.map(x=>fn(x));
    const yl = xs.map(x=>f0(x));

    const layout = {
      paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      margin:{l:54,r:16,t:16,b:44},
      xaxis:{title:'x', gridcolor:'#1d2442', color:'#cbd4ef'},
      yaxis:{title:'y', gridcolor:'#1d2442', color:'#cbd4ef'},
      showlegend:true,
      legend:{orientation:'h', y:-0.2, x:0}
    };

    // ε-band around the limit function
    const bandColor = getComputedStyle(document.documentElement)
      .getPropertyValue('--band-eps').trim() || 'rgba(255,122,158,0.18)';
    const ylo = yl.map(y => y - state.eps);
    const yhi = yl.map(y => y + state.eps);

    const trBandLo = { x: xs, y: ylo, type:'scatter', mode:'lines', line:{width:0}, name:'ε-band (low)', hoverinfo:'skip', showlegend:false };
    const trBandHi = { x: xs, y: yhi, type:'scatter', mode:'lines', fill:'tonexty', fillcolor: bandColor, line:{width:0}, name:'ε-band', hoverinfo:'skip' };
    const trFn = {x:xs, y:ys, type:'scatter', mode:'lines', line:{width:2.5, color:'#7aa2ff'}, name:'f_n'};
    const trLim = {x:xs, y:yl, type:'scatter', mode:'lines', line:{width:2.5, color:'#ff7a9e'}, name:'limit f'};

    Plotly.react('plot', [trBandLo, trBandHi, trFn, trLim], layout, {displayModeBar:false, responsive:true, scrollZoom:true, doubleClick:'reset'}).then(()=>{ btnSave.disabled=false; });

    const sup = supError(xs);
    const asup = analyticSup();
    
    // Display empirical and analytic supremum
    if (asup != null && isFinite(sup)) {
      elSup.innerHTML = `${fmt(sup)} <span style="color:var(--muted);font-size:11px;">(empirical)</span><br>${fmt(asup)} <span style="color:var(--muted);font-size:11px;">(analytic)</span>`;
    } else if (isFinite(sup)) {
      elSup.textContent = fmt(sup);
    } else {
      elSup.textContent = '— (limit undefined at some x)';
    }
    
    if (elGrid) elGrid.textContent = `${xs.length} points`;
    
    // ε-test verdict (use analytic when available)
    const testSup = asup != null ? asup : sup;
    if (isFinite(testSup)) {
      const ok = testSup <= state.eps;
      elEpsVerdict.innerHTML = `<span class="badge ${ok ? 'ok':'no'}">${ok ? 'holds':'fails'}</span>`;
    } else {
      elEpsVerdict.textContent = '—';
    }
  }

  function drawHeatmap(){
    const fam = FAMS[state.fam];
    const xs = sampleDomain();
    const Nmax = 240; // cap for compute
    const f0 = fam.lim;

    const eps = state.eps;
    const data = new Array(xs.length);
    for (let i=0;i<xs.length;i++){
      const x = xs[i];
      const L = f0(x);
      if (!Number.isFinite(L) && !Number.isNaN(L)) { data[i] = NaN; continue; }
      if (Number.isNaN(L)) { data[i] = NaN; continue; }
      let found = NaN;
      for (let n=1;n<=Nmax;n++){
        const val = Math.abs(FAMS[state.fam].f(n,x) - L);
        if (val < eps){ found = n; break; }
      }
      data[i] = found;
    }

    const z = [data.map(v=> Number.isNaN(v) ? null : v)];
    const colorscale = [
      [0,'rgb(15,18,32)'],
      [0.001,'rgb(15,18,32)'],
      [0.002,'rgb(21,26,45)'],
      [0.15,'rgb(46,65,120)'],
      [0.35,'rgb(74,102,170)'],
      [0.6,'rgb(122,162,255)'],
      [1,'rgb(255,122,158)']
    ];

    const hm = {
      z, x:xs, y:['N(ε,x)'], type:'heatmap', colorscale, showscale:true,
      zmin: 1, zmax: Nmax,
      colorbar:{title:'min n', tickcolor:'#cbd4ef', titlefont:{color:'#cbd4ef'}, tickfont:{color:'#cbd4ef'}},
      hovertemplate:'x=%{x:.6f}<br>N(ε,x)=%{z}<extra></extra>'
    };

    const layout = {
      paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      margin:{l:54,r:16,t:16,b:44},
      xaxis:{title:'x', gridcolor:'#1d2442', color:'#cbd4ef'},
      yaxis:{gridcolor:'#1d2442', color:'#cbd4ef'},
      showlegend:false
    };

    Plotly.react('plot', [hm], layout, {displayModeBar:false, responsive:true, scrollZoom:true, doubleClick:'reset'}).then(()=>{ btnSave.disabled=false; });

    elSup.textContent = '— (in heatmap mode)';
    if (elGrid) elGrid.textContent = `${xs.length} x 1`;
    elEpsVerdict.textContent = '— (in heatmap mode)';
  }

  // smooth drawing with RAF debounce
  function scheduleDraw(){
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);
  }

  // draw controller
  function draw(){
    if (state.heatmap) drawHeatmap(); else drawCurves();
    writeHash();
  }

  // events (use scheduleDraw for smooth slider interactions)
  function syncN(from){ if (from==='range') elNBox.value = elNRange.value; else elNRange.value = elNBox.value; state.n = clamp(parseInt(elNBox.value||20,10),1,300); scheduleDraw(); }
  function syncEps(from){ if (from==='range') elEpsB.value = elEpsR.value; else elEpsR.value = elEpsB.value; state.eps = Math.max(1e-6, parseFloat(elEpsB.value||0.05)); scheduleDraw(); }
  function syncW(from){ if (from==='range') elWinBox.value = elWin.value; else elWin.value = elWinBox.value; state.W = clamp(parseInt(elWinBox.value||6,10),1,20); scheduleDraw(); }
  function syncDelta(from){ if (from==='range') elDeltaBox.value = elDelta.value; else elDelta.value = elDeltaBox.value; state.delta = clamp(parseFloat(elDeltaBox.value||0,10),0,0.5); scheduleDraw(); }

  elNRange.addEventListener('input', ()=>syncN('range'));
  elNBox.addEventListener('input', ()=>syncN('box'));
  elEpsR.addEventListener('input', ()=>syncEps('range'));
  elEpsB.addEventListener('input', ()=>syncEps('box'));
  elWin.addEventListener('input', ()=>syncW('range'));
  elWinBox.addEventListener('input', ()=>syncW('box'));
  elDelta.addEventListener('input', ()=>syncDelta('range'));
  elDeltaBox.addEventListener('input', ()=>syncDelta('box'));

  elToggleMode.addEventListener('click', ()=>{ state.heatmap = !state.heatmap; syncUI(); draw(); });
  elReset.addEventListener('click', ()=>{ state.fam='xn'; state.n=20; state.eps=0.05; state.W=6; state.delta=0; state.heatmap=false; syncUI(); draw(); });

  btnSave.disabled = true;
  btnSave.addEventListener('click', async () => {
    if (!window.Plotly?.toImage) return alert('Export not supported here.');
    const gd = document.getElementById('plot');
    const url = await Plotly.toImage(gd, { format: 'png', scale: 2 });
    const a = Object.assign(document.createElement('a'), { href: url, download: 'uniform-vs-pointwise.png' });
    a.click();
  });

  // resizer (same UX as your BW tool)
  initResizer();
  function initResizer(){
    const resizer = document.getElementById('resizer');
    const left = document.querySelector('.left-panel');
    let dragging = false;
    resizer.addEventListener('pointerdown', (e)=>{
      dragging = true; resizer.setPointerCapture(e.pointerId);
      document.body.style.cursor='col-resize'; document.body.style.userSelect='none';
    });
    function onMove(e){
      if (!dragging) return;
      const rect = document.querySelector('.app').getBoundingClientRect();
      const newW = e.clientX - rect.left - 20;
      const minW = 220, maxW = Math.min(640, rect.width*0.65);
      left.style.width = Math.max(minW, Math.min(maxW, newW))+'px';
      setTimeout(()=>{ if (window.Plotly) Plotly.Plots.resize('plot'); }, 10);
    }
    function onUp(){ dragging = false; document.body.style.cursor=''; document.body.style.userSelect=''; }
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  }

  // hash watcher
  window.addEventListener('hashchange', ()=>{ if (!writingHash){ readHash(); syncUI(); draw(); }});

  // init
  function init(){
    readHash();
    // render math inside the custom list once KaTeX is ready (auto-render runs onload)
    if (window.renderMathInElement && !elFamList.hasAttribute('data-katex-rendered')){
      renderMathInElement(elFamList,{delimiters:[{left:'$$',right:'$$',display:true}]});
      elFamList.setAttribute('data-katex-rendered', 'true');
    }
    syncUI();
    updatePreview();
    updateFamButton();
    draw();
    runSanityChecks();
  }
  init();

  // --------- lightweight sanity checks (non-breaking) ---------
  function runSanityChecks(){
    try {
      // 1) Ensure the combobox button label contains rendered KaTeX (no $ signs)
      console.assert(!/[$]/.test(elFamBtnText.textContent||''), 'Combobox label should not contain $...$ math.');
      // 2) Ensure options exist
      console.assert(elFamList.querySelectorAll('[role="option"]').length===3, 'Expected 3 family options');
      // 3) Domain sampler returns points
      const xs = sampleDomain();
      console.assert(xs.length>0, 'Domain sampler returned empty array');
      // 4) Test limit functions
      console.assert(FAMS.xn.lim(1) === 1 && FAMS.xn.lim(0.5) === 0, 'xn limit function');
      console.assert(Math.abs(FAMS.sinn.f(10, Math.PI/20)) <= 1/10 + 1e-12, 'sinn bound');
      // 5) Test adaptive sampling
      const oldFam = state.fam, oldN = state.n, oldDelta = state.delta;
      state.fam = 'sinn'; state.n = 50;
      const testXs = sampleDomain();
      const testSup = supError(testXs);
      console.assert(testSup <= 1/state.n + 0.02, 'empirical sup ~ 1/n within tolerance');
      // 6) Test analytic supremums
      state.fam = 'xn'; state.n = 5;
      console.assert(analyticSup() === 1, 'xn analytic sup should be 1');
      state.fam = 'sinn'; state.n = 40;
      console.assert(Math.abs(analyticSup() - 1/state.n) < 1e-12, 'sinn analytic sup');
      state.fam = 'cauchy'; state.n = 50; state.delta = 0.1;
      console.assert(Math.abs(analyticSup() - (state.n/(1 + state.n*state.n*state.delta*state.delta))) < 1e-12, 'cauchy analytic sup with delta');
      // 7) Test ε-verdict logic
      state.fam = 'xn'; state.n = 30; state.eps = 0.2;
      console.assert(analyticSup() > state.eps, 'xn should fail ε-test for small ε');
      state.fam = oldFam; state.n = oldN; state.delta = oldDelta; // restore
    } catch(e){
      console.warn('Sanity checks warning:', e);
    }
  }
})();
</script>
</body>
</html>
